/**
 * Repository interfaces for classes, sections, and memberships
 *
 * These interfaces define the contracts for data persistence operations
 * related to the class/section organizational structure. Implementations
 * can use local storage, remote APIs, or databases without changing
 * the calling code.
 */

import { User } from '../auth/types';
import {
  Class,
  Section,
  SectionMembership,
  SectionWithClass,
  SectionStats,
  SectionFilters
} from './types';

/**
 * Repository interface for class data operations
 *
 * Manages CRUD operations for course classes (e.g., CS 101, Data Structures).
 */
export interface IClassRepository {
  /**
   * Initialize the repository.
   * Can be no-op for implementations that don't need setup.
   */
  ensureInitialized?(): Promise<void>;

  /**
   * Create a new class
   *
   * @param classData - Class data without id, createdAt, updatedAt
   * @returns The created class with generated id and timestamps
   */
  createClass(classData: Omit<Class, 'id' | 'createdAt' | 'updatedAt'>): Promise<Class>;

  /**
   * Get a class by ID
   *
   * @param classId - The class ID to retrieve
   * @param namespaceId - Optional namespace filter
   * @returns The class if found, null otherwise
   */
  getClass(classId: string, namespaceId?: string): Promise<Class | null>;

  /**
   * Update a class
   *
   * @param classId - The class ID to update
   * @param updates - Partial class data to update
   * @throws Error if class not found
   */
  updateClass(classId: string, updates: Partial<Omit<Class, 'id' | 'createdAt'>>): Promise<void>;

  /**
   * Delete a class
   *
   * Note: Consider cascading behavior for sections when implementing.
   * May want to prevent deletion if sections exist or cascade delete.
   *
   * @param classId - The class ID to delete
   * @throws Error if class not found
   */
  deleteClass(classId: string): Promise<void>;

  /**
   * List classes, optionally filtered by creator
   *
   * @param createdBy - Optional user ID to filter by creator
   * @param namespaceId - Optional namespace to filter by (system-admin only)
   * @returns Array of classes matching the filter
   */
  listClasses(createdBy?: string, namespaceId?: string): Promise<Class[]>;

  /**
   * Get all sections for a class
   *
   * @param classId - The class ID
   * @param namespaceId - Optional namespace filter
   * @returns Array of sections for the class
   */
  getClassSections(classId: string, namespaceId?: string): Promise<Section[]>;
}

/**
 * Repository interface for section data operations
 *
 * Manages CRUD operations for sections within classes.
 */
export interface ISectionRepository {
  /**
   * Initialize the repository.
   * Can be no-op for implementations that don't need setup.
   */
  ensureInitialized?(): Promise<void>;

  /**
   * Create a new section
   *
   * The join code will be auto-generated by the implementation.
   *
   * @param sectionData - Section data without id, joinCode, createdAt, updatedAt
   * @returns The created section with generated id, joinCode, and timestamps
   */
  createSection(sectionData: Omit<Section, 'id' | 'joinCode' | 'createdAt' | 'updatedAt'>): Promise<Section>;

  /**
   * Get a section by ID
   *
   * @param sectionId - The section ID to retrieve
   * @param namespaceId - Optional namespace filter
   * @returns The section if found, null otherwise
   */
  getSection(sectionId: string, namespaceId?: string): Promise<Section | null>;

  /**
   * Get a section by join code
   *
   * @param joinCode - The join code to look up
   * @returns The section if found, null otherwise
   */
  getSectionByJoinCode(joinCode: string): Promise<Section | null>;

  /**
   * Update a section
   *
   * @param sectionId - The section ID to update
   * @param updates - Partial section data to update
   * @throws Error if section not found
   */
  updateSection(sectionId: string, updates: Partial<Omit<Section, 'id' | 'createdAt'>>): Promise<void>;

  /**
   * Delete a section
   *
   * Note: Consider cascading behavior for memberships and sessions when implementing.
   *
   * @param sectionId - The section ID to delete
   * @throws Error if section not found
   */
  deleteSection(sectionId: string): Promise<void>;

  /**
   * List sections with optional filtering
   *
   * @param filters - Optional filters for classId, instructorId, or active status
   * @param namespaceId - Optional namespace to filter by (system-admin only)
   * @returns Array of sections matching the filters
   */
  listSections(filters?: SectionFilters, namespaceId?: string): Promise<Section[]>;

  /**
   * Regenerate the join code for a section
   *
   * Useful when an old join code has been compromised or shared too widely.
   * The implementation must ensure the new code is unique.
   *
   * @param sectionId - The section ID
   * @returns The new join code
   * @throws Error if section not found
   */
  regenerateJoinCode(sectionId: string): Promise<string>;

  /**
   * Add an instructor to a section
   *
   * Helper method to add an instructor ID to the instructorIds array.
   * Idempotent - if instructor already exists, no change is made.
   *
   * @param sectionId - The section ID
   * @param instructorId - The instructor user ID to add
   * @throws Error if section not found
   */
  addInstructor(sectionId: string, instructorId: string): Promise<void>;

  /**
   * Remove an instructor from a section
   *
   * Helper method to remove an instructor ID from the instructorIds array.
   * Idempotent - if instructor doesn't exist, no error is thrown.
   *
   * @param sectionId - The section ID
   * @param instructorId - The instructor user ID to remove
   * @throws Error if section not found
   */
  removeInstructor(sectionId: string, instructorId: string): Promise<void>;

  /**
   * Get statistics for a section
   *
   * @param sectionId - The section ID
   * @returns Section statistics (student count, session counts)
   */
  getSectionStats(sectionId: string): Promise<SectionStats>;
}

/**
 * Repository interface for section membership operations
 *
 * Manages the relationship between users (instructors and students) and sections.
 */
export interface IMembershipRepository {
  /**
   * Initialize the repository.
   * Can be no-op for implementations that don't need setup.
   */
  ensureInitialized?(): Promise<void>;

  /**
   * Add a membership (enroll a user in a section)
   *
   * @param membershipData - Membership data without id and joinedAt
   * @returns The created membership with generated id and timestamp
   * @throws Error if membership already exists (duplicate enrollment)
   */
  addMembership(membershipData: Omit<SectionMembership, 'id' | 'joinedAt'>): Promise<SectionMembership>;

  /**
   * Remove a membership (unenroll a user from a section)
   *
   * @param userId - The user ID
   * @param sectionId - The section ID
   * @throws Error if membership not found
   */
  removeMembership(userId: string, sectionId: string): Promise<void>;

  /**
   * Get all sections for a user, optionally filtered by role
   *
   * Returns sections with class information included for display purposes.
   *
   * @param userId - The user ID
   * @param namespaceId - Optional namespace filter
   * @param role - Optional role filter ('instructor' or 'student')
   * @returns Array of sections with class info
   */
  getUserSections(userId: string, namespaceId?: string, role?: 'instructor' | 'student'): Promise<SectionWithClass[]>;

  /**
   * Get all members (users) in a section, optionally filtered by role
   *
   * @param sectionId - The section ID
   * @param role - Optional role filter ('instructor' or 'student')
   * @returns Array of users in the section
   */
  getSectionMembers(sectionId: string, role?: 'instructor' | 'student'): Promise<User[]>;

  /**
   * Check if a user is a member of a section
   *
   * @param userId - The user ID
   * @param sectionId - The section ID
   * @returns true if the user is a member (any role), false otherwise
   */
  isMember(userId: string, sectionId: string): Promise<boolean>;

  /**
   * Get a specific membership
   *
   * @param userId - The user ID
   * @param sectionId - The section ID
   * @returns The membership if found, null otherwise
   */
  getMembership(userId: string, sectionId: string): Promise<SectionMembership | null>;
}

/**
 * Service interface for join code operations
 *
 * Handles generation and validation of section join codes, as well as
 * the join workflow for students.
 */
export interface IJoinCodeService {
  /**
   * Generate a unique join code
   *
   * Format: ABC-123-XYZ (3 segments of 3 characters each)
   * Uses letters and numbers, excluding ambiguous characters (O/0, I/1)
   *
   * @returns A unique join code
   */
  generateJoinCode(): string;

  /**
   * Validate a join code and return the section
   *
   * @param code - The join code to validate
   * @returns The section if code is valid, null otherwise
   */
  validateJoinCode(code: string): Promise<Section | null>;

  /**
   * Join a section using a join code
   *
   * This is the primary workflow for students joining a section.
   * Creates a membership with role 'student'.
   *
   * @param userId - The user ID attempting to join
   * @param joinCode - The join code for the section
   * @returns The created membership
   * @throws Error if join code is invalid
   * @throws Error if user is already a member (idempotent - could also return existing membership)
   */
  joinSection(userId: string, joinCode: string): Promise<SectionMembership>;
}
